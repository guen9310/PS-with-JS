// 문제 유형: [문자열 압축 문제, 반복문 활용 문제]
/**
 * 문제 설명:
 * 주어진 문자열 `word`를 압축하는 알고리즘을 구현합니다. `comp` 문자열을 초기화하고, `word`가 비어 있지 않은 동안 다음 연산을 반복합니다:
 * - 최대 9번 반복되는 단일 문자 `c`로 이루어진 최대 길이의 접두사를 제거합니다.
 * - 해당 접두사의 길이와 문자를 `comp`에 추가합니다.
 * 최종적으로 `comp` 문자열을 반환합니다.
 * 
 * 제한 사항:
 * 1. `word`의 길이는 1 이상 10^4 이하입니다.
 * 2. `word`는 소문자 알파벳으로만 구성됩니다.
 * 3. 동일 문자가 연속으로 나올 수 있습니다.
 * 4. 접두사는 최대 9번 반복되는 문자로 제한합니다.
 * 5. 압축된 문자열의 각 요소는 숫자와 문자로 이루어집니다.
 * 
 * 입출력 예:
 * word = "abcde" -> return "1a1b1c1d1e"
 * word = "aaaaaaaaaaaaaabb" -> return "9a5a2b"
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: "abcde"의 각 문자는 한 번씩만 나오므로, 각 문자 앞에 "1"을 붙여 "1a1b1c1d1e"가 됩니다.
 * 2. 예제 #2: "aaaaaaaaaaaaaabb"는 "a"가 9번, 5번, "b"가 2번 반복되므로, "9a5a2b"가 됩니다.
 */

function solution(word) {
    let comp = '';
    let count = 1;
    for (let i = 0; i < word.length; i++) {
        if (word[i] === word[i + 1] && count !== 9) {
            count++;
        } else {
            comp += count + word[i];
            count = 1;
        }
    }
    return comp;
}

// 입출력 예시 테스트
console.log(solution("abcde")); // 기대 값: "1a1b1c1d1e"
console.log(solution("aaaaaaaaaaaaaabb")); // 기대 값: "9a5a2b"

/**
 * 시간 복잡도:
 * O(n) - 주어진 문자열의 각 문자를 한 번씩 순회하기 때문에 선형 시간 복잡도를 가집니다.
 * 
 * 공간 복잡도:
 * O(n) - 압축된 결과를 저장할 `comp` 문자열의 길이는 최대 `word`의 길이에 비례합니다.
 */

/**
 * 개선할 점:
 * 현재 코드의 경우, 이미 효율적으로 구현되어 있으므로 별도의 개선이 필요하지 않습니다. 
 * 단, 메모리 관리가 중요한 상황에서는 문자열을 부분적으로 압축하여 저장하는 방식도 고려할 수 있지만, 
 * 이 문제의 요구사항에서는 추가적인 개선이 필요하지 않습니다.
 */