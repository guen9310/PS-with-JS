// 문제 유형: [그래프 탐색 문제, 위상 정렬 문제]
/**
 * 문제 설명:
 * n개의 팀(0번부터 n-1번까지)이 있는 토너먼트가 있습니다. 각 팀은 DAG의 노드로 간주됩니다.
 * edges 배열의 각 요소 [ui, vi]는 팀 ui가 팀 vi보다 강하다는 것을 나타내는 방향 그래프의 간선을 의미합니다.
 * 특정 팀이 토너먼트의 챔피언이 되기 위해서는 자신보다 강한 팀이 없어야 하며, 챔피언이 유일해야 합니다.
 * 유일한 챔피언이 있다면 그 팀 번호를 반환하고, 그렇지 않다면 -1을 반환하세요.
 * 
 * 제한 사항:
 * 1. 1 <= n <= 100
 * 2. 0 <= edges.length <= n * (n - 1) / 2
 * 3. edges[i].length == 2
 * 4. 0 <= edges[i][j] <= n - 1
 * 5. edges[i][0] != edges[i][1]
 * 6. 입력은 DAG (사이클이 없는 방향 그래프) 조건을 만족합니다.
 * 7. edges[i]의 [ui, vi]에서 ui가 vi보다 강하면 vi가 ui보다 강할 수 없습니다.
 * 8. 팀 a가 팀 b보다 강하고, 팀 b가 팀 c보다 강하면 팀 a는 팀 c보다 강합니다.
 * 
 * 입출력 예:
 * n = 3, edges = [[0, 1], [1, 2]] -> return 0
 * n = 4, edges = [[0, 2], [1, 3], [1, 2]] -> return -1
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: 팀 1은 팀 0보다 약하고, 팀 2는 팀 1보다 약합니다. 따라서 챔피언은 팀 0입니다.
 * 2. 예제 #2: 팀 2는 팀 0과 팀 1보다 약하고, 팀 3은 팀 1보다 약합니다. 그러나 팀 0과 팀 1 모두 자신보다 강한 팀이 없습니다. 따라서 답은 -1입니다.
 */

function solution(n, edges) {
    const map = new Map();

    for (let [_, v] of edges) {
        map.set(v, (map.get(v) || 0) + 1);
    }

    const zero = [];
    for (let i = 0; i < n; i++) {
        if (!map.has(i)) zero.push(i);
    }

    if (zero.length !== 1) return -1;
    return zero[0];
}

// 입출력 예시 테스트
console.log(solution(3, [[0, 1], [1, 2]])); // 기대 값: 0
console.log(solution(4, [[0, 2], [1, 3], [1, 2]])); // 기대 값: -1

/**
 * 시간 복잡도:
 * 간선의 개수 m에 대해 O(m)
 * 
 * 공간 복잡도:
 * O(n) (노드 및 진입 차수 기록용)
 */

/**
 * 개선할 점:
 * 현재 코드가 간단하고 명확하여 개선할 사항은 없습니다.
 */