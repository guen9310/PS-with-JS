// 문제 유형: 시뮬레이션 문제

/**
 * 문제 설명:
 * 정수 배열 `arr`와 정수 `k`가 주어집니다. 
 * 게임은 배열의 첫 번째 두 요소(arr[0]과 arr[1]) 간의 비교로 시작됩니다. 
 * 매 라운드마다 두 숫자를 비교하고 더 큰 숫자는 배열의 첫 번째 위치에 남고, 더 작은 숫자는 배열의 끝으로 이동합니다.
 * 게임은 어떤 숫자가 연속으로 `k`번 승리하면 종료됩니다.
 * 승리할 숫자를 반환하세요.
 * 
 * 제한 사항:
 * 1. 2 <= arr.length <= 10^5
 * 2. 1 <= arr[i] <= 10^6
 * 3. arr는 서로 다른 정수를 포함합니다.
 * 4. 1 <= k <= 10^9
 * 
 * 입출력 예:
 * arr = [2,1,3,5,4,6,7], k = 2 -> return 5
 * arr = [3,2,1], k = 10 -> return 3
 * 
 * 입출력 예 설명:
 * 1. 예제 #1:
 *    라운드 진행 상황:
 *    - 1 라운드: [2,1,3,5,4,6,7] -> 승자: 2, 연속 승리: 1
 *    - 2 라운드: [2,3,5,4,6,7,1] -> 승자: 3, 연속 승리: 1
 *    - 3 라운드: [3,5,4,6,7,1,2] -> 승자: 5, 연속 승리: 1
 *    - 4 라운드: [5,4,6,7,1,2,3] -> 승자: 5, 연속 승리: 2
 *    따라서 5가 승리합니다.
 * 
 * 2. 예제 #2:
 *    숫자 3이 첫 10라운드 동안 계속 승리합니다.
 */

function solution(arr, k) {
    let winner = arr[0];
    let count = 0;

    for (let i = 1; i < arr.length; i++) {
        if (winner > arr[i]) {
            count++;
        } else {
            winner = arr[i];
            count = 1;
        }

        if (count === k) {
            break;
        }
    }

    return winner;
}

// 입출력 예시 테스트
console.log(solution([2, 1, 3, 5, 4, 6, 7], 2)); // 기대 값: 5
console.log(solution([3, 2, 1], 10)); // 기대 값: 3

/**
 * 시간 복잡도:
 * O(n) 
 * - n: arr.length
 * - 최대 n번의 비교로 해결 가능
 * 
 * 공간 복잡도:
 * O(1)
 * - 추가적인 데이터 구조 없이 변수만 사용
 */

/**
 * 개선할 점:
 * - 현재 구현은 효율적이며, `k`가 매우 큰 경우(예: k > n)에도 정상적으로 작동합니다.
 * - 이보다 더 효율적인 방법은 존재하지 않습니다.
 */

// 개선된 답변은 필요하지 않습니다.