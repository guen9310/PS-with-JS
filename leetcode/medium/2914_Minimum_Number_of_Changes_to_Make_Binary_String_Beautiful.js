// 문제 유형: [탐욕법 문제]

/**
 * 문제 설명:
 * 주어진 이진 문자열 s가 있습니다. 문자열의 길이는 짝수입니다.
 * 문자열을 다음 조건에 따라 하나 이상의 부분 문자열로 분할할 수 있다면 문자열은 아름답다고 합니다:
 * - 각 부분 문자열의 길이는 짝수여야 합니다.
 * - 각 부분 문자열은 모두 1 또는 모두 0만 포함해야 합니다.
 * 
 * 문자열의 아름다움을 유지하기 위해 0 또는 1로 변환할 수 있습니다.
 * 아름다운 문자열을 만들기 위해 필요한 최소 변경 횟수를 반환합니다.
 * 
 * 제한 사항:
 * 1. 문자열 s의 길이는 짝수입니다.
 * 2. 0과 1로만 이루어져 있습니다.
 * 3. 문자열의 길이는 [2, 10^5] 사이입니다.
 * 
 * 입출력 예:
 * s = "1001" -> return 2
 * s = "10" -> return 1
 * s = "0000" -> return 0
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: s = "1001" -> s[1]을 1로, s[3]을 0으로 변경하여 "1100"을 얻습니다. "11|00"으로 분할할 수 있습니다.
 * 2. 예제 #2: s = "10" -> s[1]을 1로 변경하여 "11"을 얻습니다.
 * 3. 예제 #3: s = "0000" -> 이미 아름다운 문자열이므로 변경이 필요 없습니다.
 */

function solution(s) {
    let changes = 0;

    for (let i = 0; i < s.length; i += 2) {
        if (s[i] !== s[i + 1]) {
            changes += 1;
        }
    }
    
    return changes;
}

// 입출력 예시 테스트
console.log(solution("1001")); // 기대 값: 2
console.log(solution("10"));   // 기대 값: 1
console.log(solution("0000")); // 기대 값: 0

/**
 * 시간 복잡도:
 * O(n) - 문자열 s의 길이에 비례하는 반복문이 사용되므로, O(n) 시간 복잡도를 가집니다.
 * 
 * 공간 복잡도:
 * O(1) - 추가적인 메모리 사용이 거의 없으므로, 상수 공간 복잡도를 가집니다.
 */

/**
 * 개선할 점:
 * 현재 로직은 이미 효율적이며, 문제에서 요구한 최소 변경 횟수를 구하기에 적합합니다. 추가적인 최적화가 필요하지 않을 것으로 보입니다.
 */