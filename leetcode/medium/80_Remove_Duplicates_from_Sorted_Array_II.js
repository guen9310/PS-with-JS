// 문제 유형: 배열, 투 포인터, 중복 제거
/**
 * 문제 설명:
 * 주어진 정수 배열 `nums`는 오름차순으로 정렬되어 있습니다. 이 배열에서 중복된 요소를 제거하여 각 고유 요소가 **최대 두 번**씩만 나타나도록 하세요.
 * 중복을 제거한 후의 배열의 길이를 반환합니다.
 * 결과는 배열의 첫 번째 부분에 저장되며, 첫 `k`개의 요소는 최종 결과로 간주됩니다. 첫 `k` 요소 이후의 값들은 무시해도 됩니다.
 * 
 * 제한 사항:
 * 1. 배열 `nums`는 정수형 요소로 구성되며, 오름차순으로 정렬되어 있습니다.
 * 2. `nums`의 길이는 `0 <= nums.length <= 10^4`입니다.
 * 3. 추가적인 배열을 생성하지 않고, `O(1)`의 공간 복잡도로 문제를 해결해야 합니다.
 * 
 * 입출력 예:
 * nums = [1,1,1,2,2,3] -> return 5, nums = [1,1,2,2,3]
 * nums = [0,0,1,1,1,1,2,3,3] -> return 7, nums = [0,0,1,1,2,3,3]
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: [1,1,2,2,3]이 결과 배열이며, `k = 5`이므로 첫 다섯 개 요소가 결과로 간주됩니다.
 * 2. 예제 #2: [0,0,1,1,2,3,3]이 결과 배열이며, `k = 7`이므로 첫 일곱 개 요소가 결과로 간주됩니다.
 */

function solution(nums) {
    let i = 0;

    for (let num of nums) {
        if (i < 2 || num !== nums[i - 2]) { // 조건에 따라 중복을 제한
            nums[i] = num;
            i++;
        }
    }

    return i; // 중복을 제거한 배열의 길이
}

// 입출력 예시 테스트
console.log(solution([1,1,1,2,2,3])); // 기대 값: 5
console.log(solution([0,0,1,1,1,1,2,3,3])); // 기대 값: 7

/**
 * 시간 복잡도:
 * O(n) - 배열을 한 번 순회하며 조건을 확인하고 덮어쓰므로, n에 비례하는 시간이 소요됩니다.
 * 
 * 공간 복잡도:
 * O(1) - 입력 배열 외의 추가적인 공간을 사용하지 않으므로 O(1)입니다.
 */

/**
 * 개선할 점:
 * 이 문제는 투 포인터를 활용해 추가 배열 없이 중복을 제한하는 방식으로 구현되었으며, 별도의 최적화 여지가 적습니다.
 */
