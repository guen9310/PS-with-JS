// 탐욕법 문제
/**
 * 문제 설명:
 * 테이블 위에 n개의 공이 있습니다. 각 공은 검정색 또는 흰색입니다.
 * 길이 n의 0-인덱스 이진 문자열 s가 주어지며, 여기서 1은 검정색 공을, 0은 흰색 공을 나타냅니다.
 * 
 * 각 단계에서 인접한 두 개의 공을 선택하고 교환할 수 있습니다.
 * 모든 검정색 공을 오른쪽으로, 모든 흰색 공을 왼쪽으로 그룹화하기 위해 필요한 최소 단계 수를 반환합니다.
 * 
 * 제한 사항:
 * 1 <= n == s.length <= 10^5
 * s[i]는 '0' 또는 '1'입니다.
 * 
 * 입출력 예:
 * s = "101" -> return 1
 * s = "100" -> return 2
 * s = "0111" -> return 0
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: "101"에서 공을 교환하여 "011"로 만들 수 있으며, 검정색 공이 그룹화되기 위해 최소 1단계가 필요합니다.
 * 2. 예제 #2: "100"에서 두 번의 교환을 통해 "001"로 만들 수 있으며, 최소 2단계가 필요합니다.
 * 3. 예제 #3: "0111"은 이미 검정색 공이 오른쪽에 그룹화되어 있으므로 0단계가 필요합니다.
 */

function solution(s) {
   const arr = [...s];
    const n = arr.length;
    let steps = 0;

    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; 
                steps++;
            }
        }
    }

    return steps;
}

// 입출력 예시 테스트
console.log(solution("101")); // 기대 값: 1
console.log(solution("100")); // 기대 값: 2
console.log(solution("0111")); // 기대 값: 0

/**
 * 시간 복잡도:
 * - O(n^2), 이중 반복문을 사용하여 모든 요소를 비교합니다.
 * 
 * 공간 복잡도:
 * - O(n), 문자열을 배열로 변환하여 저장합니다.
 */

/**
 * 개선할 점:
 * - 이 로직은 대부분의 경우 작동하지만 배열의 크기가 매우 클 경우 비효율적으로 작동하여 시간 초과 에러가 발생할 수 있습니다.
 * - 불필요한 반복을 줄이기 위해 최적화할 수 있습니다.
 */

// 개선된 답변
function solutionImproved(s) {
    let count = 0;
    let combined = 0;
    for (let i = 0; i < s.length; i++){
        if (s[i] === '1') {
            combined += 1;
        } else {
            count += combined;
        }
    }
    return count;
}