// 문제 유형: [탐욕법 문제]

/**
 * 문제 설명:
 * `n`개의 주유소가 원형 경로를 따라 위치해 있습니다. 각 주유소 `i`에는 `gas[i]`만큼의 연료가 있고, `(i + 1)`번째 주유소로 이동하는 데 `cost[i]`만큼의 연료가 필요합니다.
 * 차는 무제한 크기의 연료 탱크를 가지고 있으며, 빈 상태로 시작합니다. 두 정수 배열 `gas`와 `cost`가 주어질 때, 경로를 한 바퀴 돌아 출발점으로 돌아올 수 있는 시작 주유소의 인덱스를 반환하세요. 
 * 가능한 해결 방법이 존재할 경우, 그 방법은 유일하다고 보장됩니다.
 * 
 * 제한 사항:
 * 1. `gas.length == cost.length`
 * 2. 1 <= `gas.length` <= 10^5
 * 3. 0 <= `gas[i]`, `cost[i]` <= 10^4
 * 4. 한 바퀴를 돌 수 있는 경우는 유일함이 보장됩니다.
 * 
 * 입출력 예:
 * gas = [1,2,3,4,5], cost = [3,4,5,1,2] -> return 3
 * gas = [2,3,4], cost = [3,4,3] -> return -1
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: `3번` 주유소에서 시작하면 한 바퀴를 완주할 수 있습니다.
 * 2. 예제 #2: 어떤 주유소에서도 출발해도 완주할 수 없기 때문에 `-1`을 반환합니다.
 */

function solution(gas, cost) {
    let totalGas = 0, totalCost = 0;
    let start = 0, tank = 0;

    for (let i = 0; i < gas.length; i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        tank += gas[i] - cost[i];
        
        if (tank < 0) {
            start = i + 1;
            tank = 0;
        }
    }

    return totalGas >= totalCost ? start : -1;
}

// 입출력 예시 테스트
console.log(solution([1,2,3,4,5], [3,4,5,1,2])); // 기대 값: 3
console.log(solution([2,3,4], [3,4,3]));         // 기대 값: -1

/**
 * 시간 복잡도:
 * O(n) - gas와 cost 배열을 한 번 순회하며 각 주유소에서의 연료와 비용을 계산합니다.
 * 
 * 공간 복잡도:
 * O(1) - 입력 크기에 관계없이 상수 공간만을 사용합니다.
 */

/**
 * 개선할 점:
 * 현재 코드에서는 이미 최적화된 탐욕법을 사용하여 전체 탐색 없이 각 주유소에서 필요한 최소의 계산만으로 문제를 해결하고 있습니다. 개선 여지가 크지 않습니다.
 */
