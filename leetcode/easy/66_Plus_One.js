// 문제 유형: [배열, 수학 문제]
/**
 * 문제 설명:
 * 정수 배열 `digits`가 주어집니다. 이 배열은 정수를 자릿수 단위로 표현하며, 가장 큰 자릿수가 맨 앞에 위치합니다. 배열을 나타내는 숫자에 1을 더하고, 그 결과를 다시 자릿수 배열로 반환하세요.
 * 
 * 제한 사항:
 * 1. 1 <= digits.length <= 100
 * 2. 0 <= digits[i] <= 9
 * 3. `digits`는 선행 0을 포함하지 않습니다.
 * 
 * 입출력 예:
 * digits = [1, 2, 3] -> return [1, 2, 4]
 * digits = [4, 3, 2, 1] -> return [4, 3, 2, 2]
 * digits = [9] -> return [1, 0]
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: 배열 `[1, 2, 3]`은 숫자 123을 나타냅니다. 123 + 1 = 124 이므로 결과는 `[1, 2, 4]`입니다.
 * 2. 예제 #2: 배열 `[4, 3, 2, 1]`은 숫자 4321을 나타냅니다. 4321 + 1 = 4322 이므로 결과는 `[4, 3, 2, 2]`입니다.
 * 3. 예제 #3: 배열 `[9]`은 숫자 9를 나타냅니다. 9 + 1 = 10 이므로 결과는 `[1, 0]`입니다.
 */

function solution(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        digits[i] += 1;
        if (digits[i] < 10) return digits;
        digits[i] = 0;
    }
    digits.unshift(1);
    return digits;
}

// 입출력 예시 테스트
console.log(solution([1, 2, 3])); // 기대 값: [1, 2, 4]
console.log(solution([4, 3, 2, 1])); // 기대 값: [4, 3, 2, 2]
console.log(solution([9])); // 기대 값: [1, 0]

/**
 * 시간 복잡도:
 * O(n) - 배열의 길이에 비례합니다. 끝에서부터 시작하여 각 자릿수를 한 번씩 처리합니다.
 * 
 * 공간 복잡도:
 * O(1) - 입력 배열 `digits`를 직접 수정하므로 추가적인 공간을 사용하지 않습니다.
 */

/**
 * 개선할 점:
 * 현재 솔루션은 효율적으로 작동하며, 대부분의 입력에 대해 빠르게 처리할 수 있습니다.
 */