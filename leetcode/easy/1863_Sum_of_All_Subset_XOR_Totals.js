// 동적 프로그래밍 문제
/**
 * 문제 설명:
 * 배열의 XOR 총합은 배열의 모든 요소에 대한 비트별 XOR으로 정의되며, 배열이 비어 있을 경우 0입니다.
 * 예를 들어, 배열 [2,5,6]의 XOR 총합은 2 XOR 5 XOR 6 = 1입니다.
 * 
 * 주어진 배열 nums에 대해 모든 부분 집합의 XOR 총합을 반환합니다.
 * 
 * 제한 사항:
 * 1 <= nums.length <= 12
 * 1 <= nums[i] <= 20
 * 
 * 입출력 예:
 * nums = [1,3] -> return 6
 * nums = [5,1,6] -> return 28
 * nums = [3,4,5,6,7,8] -> return 480
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: [1,3]의 4개의 부분 집합은:
 * - 빈 부분 집합의 XOR 총합은 0입니다.
 * - [1]의 XOR 총합은 1입니다.
 * - [3]의 XOR 총합은 3입니다.
 * - [1,3]의 XOR 총합은 1 XOR 3 = 2입니다.
 * 0 + 1 + 3 + 2 = 6
 * 
 * 2. 예제 #2: [5,1,6]의 8개의 부분 집합은:
 * - 빈 부분 집합의 XOR 총합은 0입니다.
 * - [5]의 XOR 총합은 5입니다.
 * - [1]의 XOR 총합은 1입니다.
 * - [6]의 XOR 총합은 6입니다.
 * - [5,1]의 XOR 총합은 5 XOR 1 = 4입니다.
 * - [5,6]의 XOR 총합은 5 XOR 6 = 3입니다.
 * - [1,6]의 XOR 총합은 1 XOR 6 = 7입니다.
 * - [5,1,6]의 XOR 총합은 5 XOR 1 XOR 6 = 2입니다.
 * 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
 * 
 * 3. 예제 #3: [3,4,5,6,7,8]의 모든 부분 집합의 XOR 총합은 480입니다.
 */

function solution(nums) {
    let sumTotal = 0;
    const n = nums.length;
    const totalSubsets = 1 << n;

    for (let i = 0; i < totalSubsets; i++) {
        let xorSum = 0;
        for (let j = 0; j < n; j++) {
            if (i & (1 << j)) {
                xorSum ^= nums[j];
            }
        }
        sumTotal += xorSum;
    }

    return sumTotal;
}

// 입출력 예시 테스트
console.log(solution([1, 3])); // 기대 값: 6
console.log(solution([5, 1, 6])); // 기대 값: 28
console.log(solution([3, 4, 5, 6, 7, 8])); // 기대 값: 480

/**
 * 시간 복잡도:
 * - 배열의 길이를 n이라고 할 때, 모든 부분 집합의 개수는 2^n입니다. 
 * - 각 부분 집합을 생성할 때, 최대 n번의 비트 연산과 XOR 연산을 수행합니다. 따라서 이중 루프가 존재하므로 전체 시간 복잡도는 O(n \cdot 2^n)입니다.
 * 
 * 공간 복잡도:
 * - 이 함수는 추가적인 배열이나 데이터 구조를 사용하지 않으므로 공간 복잡도는 O(1)입니다.
 * 
 */

/**
 * 개선할 점:
 * - 현재 알고리즘은 모든 부분 집합을 생성하여 계산하므로 비효율적입니다.
 * - 비트 연산을 이용해 각 숫자가 결과에 기여하는 횟수를 직접 계산하는 방법을 사용할 수 있습니다.
 * - 현재 방식은 동일한 XOR 값을 여러 번 계산할 수 있으므로, 이를 효율적으로 관리하면 더 나은 성능을 얻을 수 있습니다.
 */

// 개선된 답변
function solutionImproved(nums) {
    let sumTotal = 0; // 최종 XOR 총합
    const n = nums.length; // 배열의 길이

    // 각 비트에 대한 기여도 계산
    for (let i = 0; i < 32; i++) { // 32비트 정수 가정
        let count = 0; // 현재 비트 위치에서 1의 개수

        for (let num of nums) {
            // i번째 비트가 1인지 확인
            if (num & (1 << i)) {
                count++; // i번째 비트가 1이면 카운트 증가
            }
        }

        // 각 비트의 기여도 계산
        if (count > 0) {
            // 각 비트의 기여도는 count * 2^(n-1)이며
            // 각 비트가 1인 경우의 수를 더합니다.
            sumTotal += (count * (1 << i)) * (1 << (n - 1));
        }
    }

    return sumTotal; // 최종 결과 반환
}