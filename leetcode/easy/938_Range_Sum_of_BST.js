// 문제 유형: DFS(깊이 우선 탐색), 트리 탐색
/**
 * 문제 설명:
 * 주어진 이진 탐색 트리(BST)에서 두 정수 low와 high가 주어졌을 때, 그 값이 [low, high] 범위에 속하는 모든 노드의 값을 합산하여 반환하는 문제입니다.
 * 이진 탐색 트리는 왼쪽 서브트리의 모든 노드가 부모 노드보다 작고, 오른쪽 서브트리의 모든 노드가 부모 노드보다 큽니다.
 * 
 * 제한 사항:
 * 1. 트리의 노드 수는 1 이상 2 * 10^4 이하입니다.
 * 2. 각 노드의 값은 1 이상 10^5 이하입니다.
 * 3. 모든 노드의 값은 유일합니다.
 * 4. low와 high는 각각 1 이상 10^5 이하이며, low <= high 입니다.
 * 
 * 입출력 예:
 * root = [10,5,15,3,7,null,18], low = 7, high = 15 -> return 32
 * root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 -> return 23
 * 
 * 입출력 예 설명:
 * 1. 예제 #1: 7, 10, 15 값들이 [7, 15] 범위에 포함되며, 이들의 합은 32입니다.
 * 2. 예제 #2: 6, 7, 10 값들이 [6, 10] 범위에 포함되며, 이들의 합은 23입니다.
 */

function solution(root, low, high) {
    let sum = 0;

    function dfs(node) {
        if (node === null) return;

        if (node.val > low) {
            dfs(node.left);
        }

        if (low <= node.val && node.val <= high) {
            sum += node.val;
        }

        if (node.val < high) {
            dfs(node.right);
        }
    }

    dfs(root);
    return sum;
};

// 입출력 예시 테스트
console.log(solution([10,5,15,3,7,null,18], 7, 15)); // 기대 값: 32
console.log(solution([10,5,15,3,7,13,18,1,null,6], 6, 10)); // 기대 값: 23

/**
 * 시간 복잡도:
 * O(n) - 트리의 모든 노드를 한 번씩 방문하므로, n은 트리의 노드 수입니다.
 * 
 * 공간 복잡도:
 * O(h) - h는 트리의 높이로, DFS 재귀 호출이 트리의 깊이만큼 스택에 쌓이기 때문에 트리의 높이에 비례합니다.
 */

/**
 * 개선할 점:
 * 현재 알고리즘은 이진 탐색 트리(BST)의 특성을 이용해 필요한 부분만 탐색하므로, 성능 개선 여지가 거의 없습니다. 이미 효율적인 DFS 방식으로 탐색하고 있습니다.
 */